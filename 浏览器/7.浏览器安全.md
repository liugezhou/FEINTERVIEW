## 32 ｜ 同源策略：为什么XMLHttpRequest不能跨域请求资源--Web页面安全
> 浏览器安全分为三大块：Web页面安全、浏览器网络安全、浏览器系统安全。
### 同源策略
> 页面中最基础、最核心的安全策略：同源策略(same-origin policy)  
> **如果两个URL协议相同、域名相同、端口相同，就称为这两个URL同源**  
> 同源策略就是说：相同源之间可以操作DOM、读取互相之间的Cookie、indexDB、locationStorage等页面数据以及网络层面共享。  
> 也就解释了为什么同源策略限制了XMLHttpRequest讲站点数据发送给不同源站点。  

### 安全和便利性权衡
> 安全性和便利性是互斥的，比如上面的同源策略限制了一个页面中资源都需要来自一个源，也就是该页面的所有HTML文件、CSS文件和JS文件等资源需要部署在一台服务器，但是如果资源过多，或者说我们基于业务会将不同资源部署在不同服务器上，因此为了解决同源策略导致的页面资源必须来自同一个源这个限制： 
> 浏览器引入了CSP内容安全策略(Content Security policy),核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能执行内敛JavaScrip代码，通过CSP可以大大减少XSS攻击。

> 同源策略还带来的一个问题是，如果我们用XMLHttpRequest去访问另一个源，会收到限制，这个时候又引入了**CORS(跨域资源共享)策略。**  
> 使用该机制可以进行跨域访问控制，从而使得数据传输得以安全进行。

> 同源策略还有一个问题是不能互相操作DOM，同样也提供了安全的方法解决：使用**跨文档消息机制：window.postMessage**的JS接口来和不同源DOM进行通信。

## 33 | 跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？--Web页面安全
> 在同源策略的**严格**限制下，如果不能引入第三方资源，显然是不方便的，为此在安全和自由之间找的平衡，允许引入第三方资源，而随之而来的就是带来的页面安全问题，这些问题产生的过程，并进一步加深说明引入CSP机制的必要性。

### XSS攻击
> XSS全称为：Cross Site Scripting.为了与CSS区分开，所以叫CSS。    
> XSS攻击指的是劫持者往HTML文件或者DOM中注入恶意脚本，而使得用户在浏览页面时利用恶意脚本实施攻击的一种手段。  
> 当然注入JavaScript恶意脚本时，由于允许引入了第三方资源，所以浏览器无法区分这些脚本是恶意引入还是正常页面内容，注入的恶意脚本拥有所有脚本的权限，于是可能产生：窃听用户Cookie、通过addEventListener监听用户行为、修改DOM、在页面生成浮窗广告等。

### 恶意脚本注入方式
> 那么这些恶意脚本是如何注入的呢？  
> 通常情况下，恶意注入脚本的方式有三种：存储型XSS攻击、反射性XSS攻击和基于DOM的XSS攻击。  
#### 存储型XSS攻击
> 这个指的是劫持者正常访问网站，然后利用网站的漏洞将一段恶意代码提交到网站数据库中，然后别人访问这个上传恶意脚本的页面的时候，一些信息被上传到恶意代码上传的服务器中。
#### 反射型XSS攻击
> 反射型XSS攻击值得是用户将一段含有恶意代码的请求提交给Web服务器，Web服务器接收到请求再次返回给浏览器端。 
> 常见的比如通过QQ群或者邮件渠道引导用户点击恶意链接。  
> 需要与存储型XSS攻击区别的是：反射型XSS攻击中，Web服务器并不会存储攻击的请求内容。

#### 基于DOM的XSS攻击
>  这个攻击比较有技术含量，需要劫持页面，将劫持的页面中修改HTML页面内容等。 
> 这种劫持类型包括WIFI路由器劫持、本地恶意软件劫持等。共同点就是Web资源传输过程中或用户使用页面过程中劫持数据内容加以修改。

### 如何防止XSS攻击
> 存储型和反射型XSS攻击是服务端的安全漏洞，而基于DOM的XSS攻击是在浏览器端完成从，属于前端漏洞。 
> - 服务器要对输入脚本进行过滤和转码  
> - 充分利用CSP：限制加载其它源文件、禁止向第三方域提交数据、进行执行内敛脚本和未授权脚本等 
> - 使用HttpOnly属性：使用这个属性主要是为保护Cookie安全，通过服务器的HTTP响应头设置，设置之后无法通过JS来读取这段Cookie。 

## 34 | CSRF攻击：陌生链接不要随便点
> CSRF:Cross-site request forgery,跨站请求伪造。主要指侵入者引诱用户打开侵入者网站，利用用户的登录态来发起跨站请求。  
> 简单来说就是，侵入者利用用户登录态通过第三方网站做一些坏事。  

### 发起跨站请求伪造的方式有以下三种

#### 自动发起get请求
> 在第三方网站利用用户登录态调用原网址请求转账等接口来模拟原网站请求。  
> 当用户点击链接时，自动发起get请求。

#### 自动发起POST请求
> 同Get请求一样，侵入者在自己的网站使用hidden的form，自动发起POST请求。

#### 引诱用户点击链接
> 点击链接后，自动请求转账接口。

### 如何防止CSRF攻击
> CSRF攻击首先服务器有漏洞、用户登录过已有站点、且在第三方站点发起请求。
#### 充分利用好Cookie的SameSite属性
> Cookie是浏览器和服务器直接维护登录状态的一个关键数据。  
> 因此我们可以从第三方站点发送请求时禁止Cookie的发送，而Cookie中的SameSite属性就是解决这个问题的，使用SameSite可以有效减低CSRF的攻击。  
> 使用方式是：在响应头上，通过set-cookie字段设置Cookie，带上SameSite选项。  
> 通常有三个值：Strict、Lax和None。 
> - Strict最为严格，严格禁止第三方网站发起请求的时候携带Cookie。  
> - Lax:宽松一些，体现在Get请求会携带Cookie，POST和img、iframe等标签加载的URL，不会携带Cookie。 
> - None:任何情况都会携带Cookie。
#### 验证请求的来源站点
> 那么，如何来验证其ing求是来自第三方站点呢？ 
> 需要使用到HTTP请求头中的Referer和Origin属性。 
> - Referer记录HTTP请求的来源地址。 
> - 在服务器验证Referer并不是很可靠，于是加入了Origin属性。Origin属性只包含了域名信息。 
> 服务器端会验证Origin，如果不包含Origin，再根据实际情况判断是否使用Referer。

#### CSRF Token
> 类似于JWT的token。
