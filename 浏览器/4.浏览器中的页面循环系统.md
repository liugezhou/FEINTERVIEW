## 15 | 消息队列和事件循环：页面是怎么"活"起来的
> 渲染进程我们已经知道他有一个主线程，这个主线程非常非常的繁忙，要处理DOM、布局，还要处理JS任务和各种输入事件，因此为了保证不同类型任务的执行，需要一个系统来调度这些任务，这个调度系统就是本节要探究的消息队列和事件循环。 
### 引入事件循环和消息队列过程
> 1. 如果只是一些确定好的任务，然后使用一个单线程按照顺序处理这些任务就可以了，线程执行完毕退出。  
> 2. 但是在单线程执行任务的过程中，会处理新的任务，这个时候就需要引入**循环语句**和**事件循环**，循环机制保证线程会一直执行，事件循环保证可以处理临时任务。 
> 3. 接着，如果有来自其他线程的任务，这个时候就需要引入**消息队列**(一种数据结构，先进先出)了，通过从消息队列中取出其他任务，得以实现解决其他线程发过来的任务。 
> 4. 最后，还有一个情况时来自其他进程发来的任务，这个时候是通过浏览器的**IPC机制**把其他进程任务发给渲染进程的**IO进程**，IO进程再发给页面主线程。  

### 消息队列中的任务类型
> 包括：输入事件、鼠标移动、鼠标点击、鼠标滚动、微任务、文件读写、WebSocket、定时器、JS操作DOM、解析DOM、样式计算、布局阶段、CSS动画等。  
### 页面使用单线程的缺点
> 通过上面简单的学习我们知道，页面线程中的所有任务都是来自消息队列，那么：  
> 问题一：如何处理高优先级任务。  
> 问题二：如何解决单个任务执行过长的问题。

#### 如何处理高优先任务 
> 比如，如何优先处理DOM的变化。 
> 解决办法就是引入了**微任务**。  
> 我们通常把消息队列中的任务称为**宏任务**，每个宏任务包含了一个微任务队列，当执行宏任务过程中，DOM有变化了,就将这个变化添加到微任务列表中，当宏任务执行完后，不会去执行下一个宏任务，而是执行当前的微任务列表。因此就解决了实效和实时性问题。  
> 常见的宏任务:setTimeout、setIntervval、 
> 常见的微任务：Promise、process.nextTick
#### 如何解决单个任务执行时间过长的问题
> 单线程意味着每次只能执行一个任务，其他任务处于等待状态，因此为了解决一个任务执行时间过长，JS通过异步-回调功能来规避这个问题，也即让要执行的JS任务滞后执行。

## 16 | WebAPI：setTimeOut是如何实现的？
> setTimeOut的使用这里不再赘述。  
### 浏览器是怎么实现setTimeout的  
> 首先，我们知道渲染进程中所有运行在主线程上的任务都需要先添加到消息队列中去，然后事件循环系统按照顺序执行消息队列中的任务。  
> 所以说要执行一段异步任务，需要先将其放在消息队列中去。  
> 但是定时器设置回调函数有些特别，它是在一段时间间隔后执行的，但是消息队列是按顺序执行的，因此不能将定时器直接放入到消息队列中去。  
> 
> 在Chrome中，除了消息队列，还维护了一个**延迟消息队列**，定时器以及Chrome就是放到了这个延迟消息队列中去。  
### 使用setTimeout的一些注意事项
> + 如果当前任务执行过久，会影响定时器任务的执行。  
> + 如果setTimeout存在嵌套调用，那么系统会设置最短时间间隔为4ms。   
> + 未激活的页面，setTimeout执行最小间隔是1000毫秒  
> + 延时执行时间有最大值：24.8天。    
> + 使用setTimeout设置的回调函数中的this不符合直觉，使用箭头函数解决。

## 17 | WebApi：XMLHttpRequest是怎么实现的
> xhr提供了异步从Web服务器获取数据局部刷新页面的能力。  
### 同步回调和异步回调
> **将一个函数作为参数传递给另一个函数 ，这个作为参数的函数就叫做回调函数**。 
> 若回调函数在主函数返回之前执行的，我们把这个回调过程称为**同步回调**。  
> 把这种回调函数在主函数外部执行的过程称为**异步回调**。  
### 异步回调过程
> + 第一种是把异步函数做成一个任务，添加到消息对了尾部。  
> + 第二种是把异步函数添加到微任务列表中，等当前任务执行完毕就执行微任务。  
> 异步函数的两个类型不同也就导致了一个是宏任务，一个是微任务。  

### XMLHttpRequest运作机制
> + 创建XMLHttpRequest对象: let xhr = new XMLHttpRequest()    
> + 为xhr对象注册回调函数：ontimeout监控超时、onerror监控错误信息、onreadyshatechange监控后台请求过程。 
> + 通过open接口配置基础请求信息：请求地址、请求方式、请求方法、超时时间... 
> + 通过xhr.send发起请求。

### XMLHttpRequest使用过程中的坑  
> + 安全策略的跨域问题  
> + HTTPS混合内容的问题：https页面中包含了不符合https安全要求的内容(http资源) 
