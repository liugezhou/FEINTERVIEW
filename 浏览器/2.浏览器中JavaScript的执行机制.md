# 阶段二:浏览器中JavaScript的执行机制
## 07｜变量提升:JavaScript中的代码是按顺序执行的吗？
> 只有理解了JavaScript执行上下文，才能更好的理解JavaScript语言本身：变量提升、作用域、闭包等。  
### 变量提升
> 变量提升指的是:JS代码在执行过程中，JS引擎会把变量的声明部分和函数的声明部分提升到代码开头的行为，变量提升后，会给变量设置默认值，这个值就是我们熟悉的undefined。  

### JavaScript的代码执行流程
> JavaScript是**先编译后执行**，在编译阶段变量的声明和函数的声明提升到代码开头,被JS引擎放入到内存中去了。

### 编译阶段
> 输入一段代码，经过JS引擎编译后，会生成两部分内容：**执行上下文**和**可执行代码**。  
> 执行上下文是JavaScript执行一段代码的运行环境：比如调用一个函数，就会进入这个函数的执行上下文，确定函数在执行期间的诸如this、变量、对象以及函数等。  
> 要谨记在执行上下文中存在一个变量环境(Variable Enviroment)和词法环境的对象，变量环境对象中保存了变量提升的内容。 
### 执行阶段
> JS引擎执行可执行代码，按照顺序一行一行执行。执行过程中遇到一些变量或者函数就去变量变量环境中查找。
### 总结
> JavaScript代码执行过程中，需要先做变量提升，这是因为代码执行前需要先编译，编译阶段JS引擎会将变量和函数的存放到变量环境中去，变量默认值为undefined，执行阶段，JS引擎会从变量环境中查找变量和函数，若在编译阶段，存在两个相同函数，会被第二个覆盖掉。   
> 核心是要清楚JavaScript的执行机制：先编译后执行。
## 08｜调用栈：为什么JavaScript代码会出现栈溢出？ 
> 学习完执行上下文，本章学习调用栈。  
> 学习调用栈我们可以了解JavaScript引擎背后的工作原理、有调试JavaScript代码的能力。  

> 调用栈是用来管理函数调用关系的一种数据结构--这个函数调用另外一个函数。
### 函数调用
> 通过几行代码来看函数调用  
```
let a =1;
function add(){
  let b=2;
  return a + b
}
add()
```
> 1. JS引擎为上面这段代码创建全局执行上下文，将全局变量和函数都保存在全局执行上下文的变量环境中。 
> 2. 执行到add，从全局执行上下文中取出add函数 
> 3. 对add这个函数创建，函数执行上下文和可执行代码  
> 4. 此刻，拥有两个执行上下文。 
> 5. 执行上下文的管理通过叫做栈的数据结构管理(后进先出原则)--想像一个盒子，将全局执行上下文当如盒底部、再放入函数执行上下文。
### JS的调用栈
> 通常把管理执行上下文的栈成为执行上下文栈，又称调用栈，调用栈是引擎追踪函数执行的一个机制。  
> 可以通过查看浏览器的call stack或者在函数中输出console.trace()来查看调用栈。
### 栈递归溢出问题
```
function runStack(n){
  if(n===0) return 100;
  return runStack(n-2)
}
// 修改后
function runStack(n){
  if(n===0) return 100;
  return setTimeout(function(){runStack(n-2)},0)
}
```
## 09|块级作用域:var缺陷以及为什么要引入let和const
> + ES6之前没有块级作用域   
> + 变量提升使得变量容易在不被察觉的情况下被覆盖掉。  
> + 变量提升使本应销毁的变量没有被销毁


